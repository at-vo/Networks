package orchestration;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

import events.AbstractEvent;
import events.EventFactory;
import events.EventMessage;
import events.EventType;
import pubSubServer.AbstractChannel;
import pubSubServer.ChannelAccessControl;
import pubSubServer.ChannelDiscovery;
import pubSubServer.SubscriptionManager;
import publishers.AbstractPublisher;
import publishers.PublisherFactory;
import publishers.PublisherType;
import states.subscriber.StateName;
import strategies.publisher.StrategyName;
import subscribers.AbstractSubscriber;
import subscribers.SubscriberFactory;
import subscribers.SubscriberType;

public class Orchestration {

	public static void main(String[] args) {

		
		List<AbstractPublisher> listOfPublishers = new ArrayList<>();
		List<AbstractSubscriber> listOfSubscribers = new ArrayList<>();
		Orchestration testHarness = new Orchestration();

		try {
			listOfPublishers = testHarness.createPublishers();
			listOfSubscribers = testHarness.createSubscribers();

			List<AbstractChannel> channels = ChannelDiscovery.getInstance().listChannels();
			//For demonstration purposes only
			try {
				BufferedReader initialChannels = new BufferedReader(new FileReader(new File("Channels.chl")));
				List<String> channelList = new ArrayList<String>();
				String line = "";
				while((line = initialChannels.readLine()) != null )
					channelList.add(line);
				int subscriberIndex = 0;
				for(AbstractSubscriber subscriber : listOfSubscribers) {
					subscriber.subscribe(channelList.get(subscriberIndex%channelList.size()));
					subscriberIndex++;
				}
				initialChannels.close();
			}catch(IOException ioe) {
				System.out.println("Loading Channels from file failed proceeding with random selection");
				for(AbstractSubscriber subscriber : listOfSubscribers) {
					int index = (int) Math.round((Math.random()*10))/3;
					SubscriptionManager.getInstance().subscribe(channels.get(index).getChannelTopic(), subscriber);
				}
			}
			for(AbstractPublisher publisher : listOfPublishers) {
				publisher.publish();
			}

		} catch (IOException ioe) {
			System.out.println(ioe.getMessage());
			System.out.println("Will now terminate");
			return;
		}
		for(AbstractPublisher publisher : listOfPublishers) {
			publisher.publish();
		}
		try {
			int track = 0;
			BufferedReader commands = new BufferedReader(new FileReader(new File("orcha.txt")));
			while(true)
			{
				
				String line = commands.readLine();
				if (line == null)
					break;
				StringTokenizer t = new StringTokenizer(line);
				while(true)
				{
					String temp = t.nextToken();
					if (track == 0)
					{
						if(temp.equals("PUB"))
							track = 1;
						else if (temp.equals("SUB"))
							track = 2;
						else if (temp.equals("BLOCK"))
							track = 3;
						else
							track = 4;
					}
					else if (track == 1)
					{
						if(t.countTokens() == 3)
						{
							int pubID = Integer.parseInt(temp);
							int eventT = Integer.parseInt(t.nextToken());
							String eventMH = t.nextToken();
							String eventMP = t.nextToken();
							publishFunction(pubID, eventT, eventMH, eventMP, listOfPublishers);

						}
						else
						{
							int pubID = Integer.parseInt(temp);
							int eventT = Integer.parseInt(t.nextToken());
							publishFunction(pubID, listOfPublishers);
						}
						
					}
					else if (track == 2)
					{
						int subID = Integer.parseInt(temp);
						String ChannelName = t.nextToken();
						listOfSubscribers.get(subID).subscribe(ChannelName);
						System.out.println("subscriber" + subID+ "subcribed to" + ChannelName);
					}
					else if (track == 3)
					{
						int subID = Integer.parseInt(temp);
						String ChannelName = t.nextToken();
						SubscriptionManager.getInstance().block(ChannelName, listOfSubscribers.get(subID));						
					}
					else 
					{
						int subID = Integer.parseInt(temp);
						String ChannelName = t.nextToken();
						SubscriptionManager.getInstance().unBlock(ChannelName, listOfSubscribers.get(subID));						
					}
					

					if(!t.hasMoreTokens())
						break;
				}

			}
			commands.close();
		}
		
		catch (IOException e)
		{
			System.out.println("error with file");
		}
		


	}

	private static void publishFunction(int pubID, List<AbstractPublisher> listOfPublishers) {
		
		listOfPublishers.get(pubID).publish();
		System.out.println("publisher"+ pubID+"publishes alrready made event");

	}

	private static void publishFunction(int pubID, int eventT, String eventMH, String eventMP, List<AbstractPublisher> listOfPublishers)
	{	
		EventFactory e = new EventFactory();
		EventMessage temp = new EventMessage(eventMH, eventMP);
		if (eventT == 0)
		{
			AbstractEvent event = e.createEvent(EventType.EventTypeClearance,pubID, temp);
			listOfPublishers.get(pubID).publish(event);
			System.out.println("publisher" + pubID + "creates event type clearence");
		}
		else if (eventT == 1)
		{
			AbstractEvent event = e.createEvent(EventType.EventTypeNew, pubID, temp );
			listOfPublishers.get(pubID).publish(event);
			System.out.println("publisher" + pubID + "creates event type new");
		}
		else
		{
			AbstractEvent event = e.createEvent(EventType.EventTypeSale, pubID, temp );
			listOfPublishers.get(pubID).publish(event);
			System.out.println("publisher" + pubID + "creates event type sale");
		}


	}
	private List<AbstractPublisher> createPublishers() throws IOException{
		List<AbstractPublisher> listOfPublishers = new ArrayList<>();
		AbstractPublisher newPub;
		BufferedReader StrategyBufferedReader = new BufferedReader(new FileReader(new File("Strategies.str")));
		while(StrategyBufferedReader.ready()) {
			String PublisherConfigLine = StrategyBufferedReader.readLine();
			String[] PublisherConfigArray = PublisherConfigLine.split("\t");
			int[] PublisherConfigIntArray = new int[2];
			for(int i = 0; i < PublisherConfigArray.length; i++)
				PublisherConfigIntArray[i] = Integer.parseInt(PublisherConfigArray[i]);
			newPub = PublisherFactory.createPublisher(
					PublisherType.values()[PublisherConfigIntArray[0]],
					StrategyName.values()[PublisherConfigIntArray[1]]);
			listOfPublishers.add(newPub);
		}
		StrategyBufferedReader.close();
		return listOfPublishers;
	}

	private List<AbstractSubscriber> createSubscribers() throws IOException{
		List<AbstractSubscriber> listOfSubscribers = new ArrayList<>();
		AbstractSubscriber newSub;
		BufferedReader StateBufferedReader = new BufferedReader(new FileReader(new File("States.sts")));
		while(StateBufferedReader.ready()) {
			String StateConfigLine = StateBufferedReader.readLine();
			String[] StateConfigArray = StateConfigLine.split("\t");
			int[] StateConfigIntArray = new int[2];
			for(int i = 0; i < StateConfigArray.length; i++)
				StateConfigIntArray[i] = Integer.parseInt(StateConfigArray[i]);
			newSub = SubscriberFactory.createSubscriber(
					SubscriberType.values()[StateConfigIntArray[0]], 
					StateName.values()[StateConfigIntArray[1]]);
			listOfSubscribers.add(newSub);
		}
		StateBufferedReader.close();
		return listOfSubscribers;
	}



}
